# 開発ログ #000001: Basic認証の実装

## 対象フェーズ

認証機能の追加（Phase: 認証機能）

## 実施日

2026-01-12

## 実施内容の要約

### 目的

自分専用のアプリとして、第三者からのアクセスを防ぐためBasic認証を実装する。

### 完了したタスク

1. 仕様書（specification.md）に認証要件を追記
2. TODO.mdに認証タスクを追加
3. Basic認証のユニットテスト作成（`test/auth/basic-auth.test.ts`）
4. Basic認証の実装（`app/server.ts`）
5. 型定義の更新（`app/global.d.ts`）
6. `.dev.vars.example`テンプレート作成
7. デプロイ手順書の更新（`documents/20260112_user_instruction.md`）

### 変更ファイル一覧

| ファイル | 変更種別 | 内容 |
|---------|---------|------|
| `app/server.ts` | 修正 | fetchハンドラでBasic認証を実装 |
| `app/global.d.ts` | 修正 | `BASIC_AUTH_USER`, `BASIC_AUTH_PASS`の型定義追加 |
| `.dev.vars.example` | 新規 | 環境変数テンプレート |
| `test/auth/basic-auth.test.ts` | 新規 | Basic認証のユニットテスト |
| `documents/specification.md` | 修正 | 認証要件を追記 |
| `documents/TODO.md` | 修正 | 認証タスクを追加・完了 |
| `documents/20260112_user_instruction.md` | 修正 | secrets設定手順を追加 |

---

## 技術的判断・理由

### 認証方式の選定

**選択肢:**
1. Basic認証（`hono/basic-auth`）
2. Cloudflare Access（ゼロトラスト認証）

**決定:** Basic認証

**理由:**
- シンプルで追加コストなし
- 自分専用のため複雑な認証は不要
- Cloudflare Workers secretsで認証情報を安全に管理可能

### HonoXでのミドルウェア適用方法

**試行1: `app/routes/_middleware.ts`の使用**
- HonoXの推奨方法として`_middleware.ts`を作成
- 結果: **失敗** - ミドルウェアが適用されなかった

**試行2: `createApp({ init })`オプション**
- `createApp`の`init`オプションでミドルウェアを追加
- 結果: **失敗** - 同様に適用されなかった

**試行3: ラッパーアプリで`app.route()`**
- 別のHonoインスタンスでミドルウェアを適用し、HonoXアプリをマウント
- 結果: **失敗** - `route()`ではサブアプリのルートにミドルウェアが適用されない

**試行4: fetchハンドラで直接認証（採用）**
- Workerのfetchハンドラで認証を行い、成功後にHonoXアプリに委譲
- 結果: **成功**

**教訓:**
HonoXはファイルベースルーティングの抽象化が強く、従来のHonoミドルウェアパターンが適用しにくい場合がある。Workerレベルでの認証が最も確実。

### ビルドの必要性

- `npm run preview`（wrangler dev）は`dist/index.js`を参照
- ソースコード変更後は`npm run build`が必要
- 初回テストで変更が反映されず混乱した

---

## 問題点・反省

### 1. HonoXのミドルウェア仕様の理解不足

HonoXでのミドルウェア適用方法について、複数のアプローチを試行錯誤した。事前にHonoXのドキュメントをより詳細に確認すべきだった。

### 2. ビルドキャッシュの認識不足

`npm run preview`がビルド出力を使用することを認識しておらず、ソースコード変更が反映されない問題に遭遇した。

### 3. ローカルDBマイグレーションの未適用

初回テストで「no such table: mangas」エラーが発生。ローカルDBにマイグレーションが適用されていなかった。

---

## テスト結果

```
 ✓ test/lib/slack.test.ts (4 tests)
 ✓ test/auth/basic-auth.test.ts (5 tests)
 ✓ test/cron/scheduled.test.ts (8 tests)
 ✓ test/api/settings.test.ts (7 tests)
 ✓ test/api/mangas-id.test.ts (7 tests)
 ✓ test/api/mangas.test.ts (8 tests)

 Test Files  6 passed (6)
      Tests  39 passed (39)
```

### ローカル動作確認

```
認証なし      → 401 Unauthorized ✓
間違った認証  → 401 Unauthorized ✓
正しい認証    → 200 OK ✓
```

---

## 次フェーズへの申し送り

1. **デプロイ前の作業**
   - Cloudflareにログイン: `npx wrangler login`
   - リモートD1データベース作成: `npx wrangler d1 create manga-update-notifier-db`
   - wrangler.jsonの`database_id`を更新
   - マイグレーション適用: `npx wrangler d1 migrations apply DB --remote`
   - secrets設定:
     ```bash
     npx wrangler secret put BASIC_AUTH_USER
     npx wrangler secret put BASIC_AUTH_PASS
     ```

2. **デプロイ**
   ```bash
   npm run deploy
   ```

3. **動作確認**
   - Basic認証のダイアログが表示されることを確認
   - 認証後、漫画一覧ページが表示されることを確認
   - Slack Webhook URLを設定

---

## 参考情報

### 認証情報の管理

| 環境 | 方法 |
|-----|------|
| ローカル開発 | `.dev.vars`ファイル（gitignore対象） |
| 本番環境 | Cloudflare Workers secrets |

### 実装コード（server.ts抜粋）

```typescript
// Basic認証のヘルパー関数
function verifyBasicAuth(
  request: Request,
  username: string,
  password: string
): boolean {
  const authHeader = request.headers.get('Authorization')
  if (!authHeader || !authHeader.startsWith('Basic ')) {
    return false
  }
  const base64Credentials = authHeader.slice(6)
  const credentials = atob(base64Credentials)
  const [user, pass] = credentials.split(':')
  return user === username && pass === password
}

// fetchハンドラで認証
export default {
  fetch: async (request, env, ctx) => {
    if (!verifyBasicAuth(request, env.BASIC_AUTH_USER, env.BASIC_AUTH_PASS)) {
      return unauthorizedResponse()
    }
    return app.fetch(request, env, ctx)
  },
  // ...
}
```

# Dev Log 000001 - Phase 0: 準備・設計確認

## 対象フェーズ
Phase 0: 準備・設計確認

## 実施日
2026-01-13

## 実施内容の要約

### 1. 既存コードの調査
- `app/lib/manga-handlers.ts` に既存の `Manga`, `MangaRow` 型定義を確認
- `app/lib/cron-handler.ts` に既存のスケジュール判定ロジック（曜日ベース）を確認
- テスト構造: Vitest + Cloudflare vitest-pool-workers、`test/` ディレクトリに統合テスト

### 2. 新しい型定義の設計
- `ScheduleType`: `'weekly' | 'biweekly' | 'monthly'`
- `Manga` 型に追加するフィールド:
  - `scheduleType`: 通知パターン
  - `dayOfWeek`: 曜日（NULLable化）
  - `monthlyDays`: 月次の日付配列
  - `baseDate`: 隔週の基準日
- `MangaRow` 型も同様にsnake_caseで追加

### 3. ユーティリティ関数の設計
- スケジュール判定関数:
  - `shouldNotifyWeekly(manga, today)`
  - `shouldNotifyBiweekly(manga, today)`
  - `shouldNotifyMonthly(manga, today)`
  - `shouldNotify(manga, today)` - 統合関数
- 次回通知日計算関数:
  - `getNextBiweeklyDate(dayOfWeek, baseDate, fromDate?)`
- ヘルパー関数:
  - `getWeeksSinceBase(baseDate, targetDate)`
  - `isValidDayInMonth(year, month, day)`

## 技術的判断・理由

### 型設計
- `dayOfWeek` を NULLable にした理由: 月次パターンでは曜日は不要なため
- `monthlyDays` を JSON 文字列で保存する理由: D1（SQLite）で配列型がサポートされていないため
- `baseDate` を ISO 8601 形式にした理由: パース・比較が容易、タイムゾーン考慮可能

### 関数設計
- 各パターン専用の判定関数を分離した理由: 単体テストが書きやすい、責務が明確
- 統合関数 `shouldNotify` を設けた理由: Cronハンドラーからの呼び出しをシンプルにするため

## レビュー内容と対応
- ユーザーレビュー: LGTM
- 指摘事項: なし

## 問題点・反省
- 特になし

## 次フェーズへの申し送り
- Phase 1: DBマイグレーション作成
  - `schedule_type` カラム（DEFAULT 'weekly'）
  - `monthly_days` カラム（NULL許容）
  - `base_date` カラム（NULL許容）
  - 既存データの `schedule_type` を 'weekly' に設定

